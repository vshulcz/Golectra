// Command reset generates Reset() methods for structs marked with "// generate:reset" comment.
// It supports basic types, slices, maps, pointers, and nested structs.
// For structs from other packages, it assigns zero values instead of resetting fields.
package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

const marker = "generate:reset"

func main() {
	root, err := findModuleRoot()
	if err != nil {
		log.Fatal(err)
	}

	cfg := &packages.Config{
		Dir: root,
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedCompiledGoFiles |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo,
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatal(err)
	}

	for _, p := range pkgs {
		if len(p.Errors) > 0 {
			var b strings.Builder
			fmt.Fprintf(&b, "package load errors:\n")
			for _, e := range p.Errors {
				fmt.Fprintf(&b, " - %s\n", e)
			}
			log.Fatal(b.String())
		}
	}

	changed := 0
	for _, p := range pkgs {
		if len(p.CompiledGoFiles) == 0 {
			continue
		}

		targets := findTargetStructs(p)
		outPath := filepath.Join(filepath.Dir(p.CompiledGoFiles[0]), "reset.gen.go")

		if len(targets) == 0 {
			if err := os.Remove(outPath); err == nil {
				changed++
			} else if !errors.Is(err, os.ErrNotExist) {
				log.Fatalf("remove %s: %v", outPath, err)
			}
			continue
		}

		src, err := generateResetFile(p, targets)
		if err != nil {
			log.Fatalf("generate for %s: %v", p.PkgPath, err)
		}

		cleanPath := filepath.Clean(outPath)
		old, err := os.ReadFile(cleanPath)
		if err != nil {
			log.Fatalf("read %s: %v", outPath, err)
		}
		if bytes.Equal(old, src) {
			continue
		}
		if err := os.WriteFile(cleanPath, src, 0o600); err != nil {
			log.Fatalf("write %s: %v", outPath, err)
		}
		changed++
	}

	log.Printf("reset: done (changed %d file(s))", changed)
}

// findModuleRoot finds the root directory of the Go module by looking for go.mod file upwards from the current working directory.
func findModuleRoot() (string, error) {
	wd, err := os.Getwd()
	if err != nil {
		return "", err
	}
	dir := wd

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found вверх по дереву от %s", wd)
}

type targetStruct struct {
	Name  string
	Named *types.Named
}

func findTargetStructs(pkg *packages.Package) []targetStruct {
	var out []targetStruct

	for _, f := range pkg.Syntax {
		for _, decl := range f.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}

			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				_, ok = ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if !hasMarker(gd.Doc, ts.Doc) {
					continue
				}

				obj := pkg.Types.Scope().Lookup(ts.Name.Name)
				tn, ok := obj.(*types.TypeName)
				if !ok {
					continue
				}
				named, ok := tn.Type().(*types.Named)
				if !ok {
					continue
				}

				if hasResetMethod(named) || hasResetMethod(types.NewPointer(named)) {
					log.Printf("reset: skip %s.%s (Reset already exists)", pkg.PkgPath, ts.Name.Name)
					continue
				}

				out = append(out, targetStruct{
					Name:  ts.Name.Name,
					Named: named,
				})
			}
		}
	}

	sort.Slice(out, func(i, j int) bool { return out[i].Name < out[j].Name })
	return out
}

func hasMarker(genDoc, specDoc *ast.CommentGroup) bool {
	check := func(cg *ast.CommentGroup) bool {
		if cg == nil {
			return false
		}
		for _, c := range cg.List {
			txt := c.Text
			txt = strings.TrimSpace(txt)
			txt = strings.ToLower(txt)
			txt = strings.TrimPrefix(txt, "//")
			txt = strings.TrimPrefix(txt, "/*")
			txt = strings.TrimSuffix(txt, "*/")
			txt = strings.TrimSpace(txt)

			if txt == "+"+marker {
				return true
			}
		}
		return false
	}

	return check(specDoc) || check(genDoc)
}

func generateResetFile(pkg *packages.Package, targets []targetStruct) ([]byte, error) {
	im := newImportManager(pkg.PkgPath)

	var w codeWriter
	w.line(0, "// Code generated by cmd/reset; DO NOT EDIT.")
	w.line(0, "")
	w.line(0, "package "+pkg.Name)
	w.line(0, "")

	var methods bytes.Buffer
	mw := codeWriter{buf: &methods}

	for _, t := range targets {
		if err := emitResetMethod(&mw, im, pkg, t); err != nil {
			return nil, err
		}
		mw.line(0, "")
	}

	imports := im.sortedImports()
	if len(imports) > 0 {
		w.line(0, "import (")
		for _, imp := range imports {
			if imp.Alias == "" {
				w.line(1, fmt.Sprintf("%q", imp.Path))
			} else {
				w.line(1, fmt.Sprintf("%s %q", imp.Alias, imp.Path))
			}
		}
		w.line(0, ")")
		w.line(0, "")
	}

	w.buf.Write(methods.Bytes())

	formatted, err := format.Source(w.buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format: %w\n\n%s", err, w.buf.String())
	}
	return formatted, nil
}

func emitResetMethod(w *codeWriter, im *importManager, pkg *packages.Package, t targetStruct) error {
	st, ok := t.Named.Underlying().(*types.Struct)
	if !ok {
		return fmt.Errorf("%s is not a struct type", t.Name)
	}

	recv := "x"
	w.line(0, fmt.Sprintf("func (%s *%s) Reset() {", recv, t.Name))
	w.line(1, fmt.Sprintf("if %s == nil {", recv))
	w.line(2, "return")
	w.line(1, "}")
	w.line(0, "")

	for i := 0; i < st.NumFields(); i++ {
		f := st.Field(i)
		fieldExpr := recv + "." + f.Name()
		emitResetForExpr(w, im, pkg.PkgPath, fieldExpr, f.Type())
	}

	w.line(0, "}")
	return nil
}

type codeWriter struct {
	buf *bytes.Buffer
}

func (w *codeWriter) ensure() {
	if w.buf == nil {
		w.buf = &bytes.Buffer{}
	}
}

func (w *codeWriter) line(indent int, s string) {
	w.ensure()
	for i := 0; i < indent; i++ {
		w.buf.WriteByte('\t')
	}
	w.buf.WriteString(s)
	w.buf.WriteByte('\n')
}

type importSpec struct {
	Path  string
	Alias string
}

type importManager struct {
	localPkgPath string
	byPath       map[string]string
	usedAlias    map[string]bool
}

func newImportManager(localPkgPath string) *importManager {
	return &importManager{
		localPkgPath: localPkgPath,
		byPath:       map[string]string{},
		usedAlias:    map[string]bool{},
	}
}

func (im *importManager) qualifier(p *types.Package) string {
	if p == nil {
		return ""
	}
	if p.Path() == im.localPkgPath {
		return ""
	}
	if alias, ok := im.byPath[p.Path()]; ok {
		return alias
	}

	base := p.Name()
	alias := base
	if im.usedAlias[alias] {
		for i := 2; ; i++ {
			alias = fmt.Sprintf("%s%d", base, i)
			if !im.usedAlias[alias] {
				break
			}
		}
	}
	im.usedAlias[alias] = true
	im.byPath[p.Path()] = alias
	return alias
}

func (im *importManager) typeString(t types.Type) string {
	return types.TypeString(t, im.qualifier)
}

func (im *importManager) sortedImports() []importSpec {
	paths := make([]string, 0, len(im.byPath))
	for p := range im.byPath {
		paths = append(paths, p)
	}
	sort.Strings(paths)

	out := make([]importSpec, 0, len(paths))
	for _, p := range paths {
		alias := im.byPath[p]

		last := p
		if idx := strings.LastIndex(p, "/"); idx >= 0 {
			last = p[idx+1:]
		}
		if alias == last {
			alias = ""
		}

		out = append(out, importSpec{Path: p, Alias: alias})
	}
	return out
}

func emitResetForExpr(w *codeWriter, im *importManager, localPkgPath, expr string, t types.Type) {
	u := t.Underlying()

	switch tt := u.(type) {
	case *types.Basic:
		w.line(1, fmt.Sprintf("%s = %s", expr, zeroBasic(tt)))
		return

	case *types.Slice:
		w.line(1, fmt.Sprintf("%s = %s[:0]", expr, expr))
		return

	case *types.Map:
		w.line(1, fmt.Sprintf("clear(%s)", expr))
		return

	case *types.Pointer:
		ptrExpr := expr
		w.line(1, fmt.Sprintf("if %s != nil {", ptrExpr))
		emitResetThroughPointer(w, im, localPkgPath, ptrExpr, tt.Elem())
		w.line(1, "}")
		return

	case *types.Struct:
		if hasResetMethod(types.NewPointer(t)) {
			w.line(1, fmt.Sprintf("(&%s).Reset()", expr))
			return
		}
		if hasResetMethod(t) {
			w.line(1, fmt.Sprintf("%s.Reset()", expr))
			return
		}

		if st, ok := accessibleStruct(t, localPkgPath); ok {
			for i := 0; i < st.NumFields(); i++ {
				f := st.Field(i)
				emitResetForExpr(w, im, localPkgPath, expr+"."+f.Name(), f.Type())
			}
			return
		}

		w.line(1, fmt.Sprintf("%s = %s{}", expr, im.typeString(t)))
		return

	case *types.Array:
		w.line(1, fmt.Sprintf("%s = %s{}", expr, im.typeString(t)))
		return

	default:
		w.line(1, fmt.Sprintf("%s = %s", expr, zeroExpr(im, t)))
		return
	}
}

func emitResetThroughPointer(w *codeWriter, im *importManager, localPkgPath, ptrExpr string, elem types.Type) {
	u := elem.Underlying()

	switch tt := u.(type) {
	case *types.Basic:
		w.line(2, fmt.Sprintf("*%s = %s", ptrExpr, zeroBasic(tt)))
		return

	case *types.Slice:
		w.line(2, fmt.Sprintf("*%s = (*%s)[:0]", ptrExpr, ptrExpr))
		return

	case *types.Map:
		w.line(2, fmt.Sprintf("clear(*%s)", ptrExpr))
		return

	case *types.Pointer:
		w.line(2, fmt.Sprintf("if *%s != nil {", ptrExpr))
		emitResetThroughPointer(w, im, localPkgPath, "*"+ptrExpr, tt.Elem())
		w.line(2, "}")
		return

	case *types.Struct:
		if hasResetMethod(types.NewPointer(elem)) {
			w.line(2, fmt.Sprintf("%s.Reset()", ptrExpr))
			return
		}

		if st, ok := accessibleStruct(elem, localPkgPath); ok {
			for i := 0; i < st.NumFields(); i++ {
				f := st.Field(i)
				emitResetForExpr(w, im, localPkgPath, ptrExpr+"."+f.Name(), f.Type())
			}
			return
		}

		w.line(2, fmt.Sprintf("*%s = %s{}", ptrExpr, im.typeString(elem)))
		return

	case *types.Array:
		w.line(2, fmt.Sprintf("*%s = %s{}", ptrExpr, im.typeString(elem)))
		return

	default:
		w.line(2, fmt.Sprintf("*%s = %s", ptrExpr, zeroExpr(im, elem)))
		return
	}
}

func accessibleStruct(t types.Type, localPkgPath string) (*types.Struct, bool) {
	switch tt := t.(type) {
	case *types.Struct:
		return tt, true
	case *types.Named:
		st, ok := tt.Underlying().(*types.Struct)
		if !ok {
			return nil, false
		}
		if tt.Obj() != nil && tt.Obj().Pkg() != nil && tt.Obj().Pkg().Path() == localPkgPath {
			return st, true
		}
		return nil, false
	default:
		return nil, false
	}
}

func hasResetMethod(t types.Type) bool {
	ms := types.NewMethodSet(t)
	for i := 0; i < ms.Len(); i++ {
		sel := ms.At(i)
		if sel.Obj().Name() != "Reset" {
			continue
		}
		fn, ok := sel.Obj().(*types.Func)
		if !ok {
			continue
		}
		sig, ok := fn.Type().(*types.Signature)
		if !ok {
			continue
		}
		if sig.Params().Len() == 0 && sig.Results().Len() == 0 {
			return true
		}
	}
	return false
}

func zeroBasic(b *types.Basic) string {
	switch b.Kind() {
	case types.Bool:
		return "false"
	case types.String:
		return `""`
	case types.UntypedNil:
		const nilString = "nil"
		return nilString
	default:
		return "0"
	}
}

func zeroExpr(im *importManager, t types.Type) string {
	u := t.Underlying()

	switch u := u.(type) {
	case *types.Basic:
		return zeroBasic(u)
	case *types.Slice, *types.Map, *types.Chan, *types.Signature, *types.Interface, *types.Pointer:
		return "nil"
	case *types.Struct, *types.Array:
		return im.typeString(t) + "{}"
	default:
		return "nil"
	}
}
