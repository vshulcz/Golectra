package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"golang.org/x/tools/go/packages"
)

const marker = "generate:reset"

type targetStruct struct {
	Name  string
	Named *types.Named
}

func processPackages(root string) {
	cfg := &packages.Config{
		Dir: root,
		Mode: packages.NeedName |
			packages.NeedFiles |
			packages.NeedCompiledGoFiles |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo,
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		log.Fatal(err)
	}

	changed := 0
	for _, p := range pkgs {
		if len(p.Errors) > 0 {
			var b strings.Builder
			fmt.Fprintf(&b, "package load errors:\n")
			for _, e := range p.Errors {
				fmt.Fprintf(&b, " - %s\n", e)
			}
			log.Fatal(b.String())
		}

		if len(p.CompiledGoFiles) == 0 {
			continue
		}

		targets := findTargetStructs(p)
		outPath := filepath.Join(filepath.Dir(p.CompiledGoFiles[0]), "reset.gen.go")

		if len(targets) == 0 {
			if err := os.Remove(outPath); err == nil {
				changed++
			} else if !errors.Is(err, os.ErrNotExist) {
				log.Fatalf("remove %s: %v", outPath, err)
			}
			continue
		}

		src, err := generateResetFile(p, targets)
		if err != nil {
			log.Fatalf("generate for %s: %v", p.PkgPath, err)
		}

		cleanPath := filepath.Clean(outPath)
		old, err := os.ReadFile(cleanPath)
		if err == nil && bytes.Equal(old, src) {
			continue
		}
		if err := os.WriteFile(cleanPath, src, 0o600); err != nil {
			log.Fatalf("write %s: %v", outPath, err)
		}
		changed++
	}

	log.Printf("reset: done (changed %d file(s))", changed)
}

func findTargetStructs(pkg *packages.Package) []targetStruct {
	var out []targetStruct

	for _, f := range pkg.Syntax {
		for _, decl := range f.Decls {
			gd, ok := decl.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}

			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				_, ok = ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if !hasMarker(gd.Doc, ts.Doc) {
					continue
				}

				obj := pkg.Types.Scope().Lookup(ts.Name.Name)
				tn, ok := obj.(*types.TypeName)
				if !ok {
					continue
				}
				named, ok := tn.Type().(*types.Named)
				if !ok {
					continue
				}

				if hasResetMethod(named) || hasResetMethod(types.NewPointer(named)) {
					log.Printf("reset: skip %s.%s (Reset already exists)", pkg.PkgPath, ts.Name.Name)
					continue
				}

				out = append(out, targetStruct{
					Name:  ts.Name.Name,
					Named: named,
				})
			}
		}
	}

	sort.Slice(out, func(i, j int) bool { return out[i].Name < out[j].Name })
	return out
}

func generateResetFile(pkg *packages.Package, targets []targetStruct) ([]byte, error) {
	im := newImportManager(pkg.PkgPath)

	var w codeWriter
	w.line(0, "// Code generated by cmd/reset; DO NOT EDIT.")
	w.line(0, "")
	w.line(0, "package "+pkg.Name)
	w.line(0, "")

	var methods bytes.Buffer
	mw := codeWriter{buf: &methods}

	for _, t := range targets {
		if err := emitResetMethod(&mw, im, pkg, t); err != nil {
			return nil, err
		}
		mw.line(0, "")
	}

	imports := im.sortedImports()
	if len(imports) > 0 {
		w.line(0, "import (")
		for _, imp := range imports {
			if imp.Alias == "" {
				w.line(1, fmt.Sprintf("%q", imp.Path))
			} else {
				w.line(1, fmt.Sprintf("%s %q", imp.Alias, imp.Path))
			}
		}
		w.line(0, ")")
		w.line(0, "")
	}

	w.buf.Write(methods.Bytes())

	formatted, err := format.Source(w.buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format: %w\n\n%s", err, w.buf.String())
	}
	return formatted, nil
}
